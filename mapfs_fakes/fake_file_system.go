// Code generated by counterfeiter. DO NOT EDIT.
package mapfs_fakes

import (
	"sync"
	"time"

	"github.com/hanwen/go-fuse/v2/fuse"
	"github.com/hanwen/go-fuse/v2/fuse/nodefs"
	"github.com/hanwen/go-fuse/v2/fuse/pathfs"
)

type FakeFileSystem struct {
	AccessStub        func(string, uint32, *fuse.Context) fuse.Status
	accessMutex       sync.RWMutex
	accessArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}
	accessReturns struct {
		result1 fuse.Status
	}
	accessReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	ChmodStub        func(string, uint32, *fuse.Context) fuse.Status
	chmodMutex       sync.RWMutex
	chmodArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}
	chmodReturns struct {
		result1 fuse.Status
	}
	chmodReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	ChownStub        func(string, uint32, uint32, *fuse.Context) fuse.Status
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 uint32
		arg4 *fuse.Context
	}
	chownReturns struct {
		result1 fuse.Status
	}
	chownReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	CreateStub        func(string, uint32, uint32, *fuse.Context) (nodefs.File, fuse.Status)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 uint32
		arg4 *fuse.Context
	}
	createReturns struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	createReturnsOnCall map[int]struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	GetAttrStub        func(string, *fuse.Context) (*fuse.Attr, fuse.Status)
	getAttrMutex       sync.RWMutex
	getAttrArgsForCall []struct {
		arg1 string
		arg2 *fuse.Context
	}
	getAttrReturns struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}
	getAttrReturnsOnCall map[int]struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}
	GetXAttrStub        func(string, string, *fuse.Context) ([]byte, fuse.Status)
	getXAttrMutex       sync.RWMutex
	getXAttrArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}
	getXAttrReturns struct {
		result1 []byte
		result2 fuse.Status
	}
	getXAttrReturnsOnCall map[int]struct {
		result1 []byte
		result2 fuse.Status
	}
	LinkStub        func(string, string, *fuse.Context) fuse.Status
	linkMutex       sync.RWMutex
	linkArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}
	linkReturns struct {
		result1 fuse.Status
	}
	linkReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	ListXAttrStub        func(string, *fuse.Context) ([]string, fuse.Status)
	listXAttrMutex       sync.RWMutex
	listXAttrArgsForCall []struct {
		arg1 string
		arg2 *fuse.Context
	}
	listXAttrReturns struct {
		result1 []string
		result2 fuse.Status
	}
	listXAttrReturnsOnCall map[int]struct {
		result1 []string
		result2 fuse.Status
	}
	MkdirStub        func(string, uint32, *fuse.Context) fuse.Status
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}
	mkdirReturns struct {
		result1 fuse.Status
	}
	mkdirReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	MknodStub        func(string, uint32, uint32, *fuse.Context) fuse.Status
	mknodMutex       sync.RWMutex
	mknodArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 uint32
		arg4 *fuse.Context
	}
	mknodReturns struct {
		result1 fuse.Status
	}
	mknodReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	OnMountStub        func(*pathfs.PathNodeFs)
	onMountMutex       sync.RWMutex
	onMountArgsForCall []struct {
		arg1 *pathfs.PathNodeFs
	}
	OnUnmountStub        func()
	onUnmountMutex       sync.RWMutex
	onUnmountArgsForCall []struct {
	}
	OpenStub        func(string, uint32, *fuse.Context) (nodefs.File, fuse.Status)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}
	openReturns struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	openReturnsOnCall map[int]struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	OpenDirStub        func(string, *fuse.Context) ([]fuse.DirEntry, fuse.Status)
	openDirMutex       sync.RWMutex
	openDirArgsForCall []struct {
		arg1 string
		arg2 *fuse.Context
	}
	openDirReturns struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}
	openDirReturnsOnCall map[int]struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}
	ReadlinkStub        func(string, *fuse.Context) (string, fuse.Status)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		arg1 string
		arg2 *fuse.Context
	}
	readlinkReturns struct {
		result1 string
		result2 fuse.Status
	}
	readlinkReturnsOnCall map[int]struct {
		result1 string
		result2 fuse.Status
	}
	RemoveXAttrStub        func(string, string, *fuse.Context) fuse.Status
	removeXAttrMutex       sync.RWMutex
	removeXAttrArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}
	removeXAttrReturns struct {
		result1 fuse.Status
	}
	removeXAttrReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	RenameStub        func(string, string, *fuse.Context) fuse.Status
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}
	renameReturns struct {
		result1 fuse.Status
	}
	renameReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	RmdirStub        func(string, *fuse.Context) fuse.Status
	rmdirMutex       sync.RWMutex
	rmdirArgsForCall []struct {
		arg1 string
		arg2 *fuse.Context
	}
	rmdirReturns struct {
		result1 fuse.Status
	}
	rmdirReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	SetDebugStub        func(bool)
	setDebugMutex       sync.RWMutex
	setDebugArgsForCall []struct {
		arg1 bool
	}
	SetXAttrStub        func(string, string, []byte, int, *fuse.Context) fuse.Status
	setXAttrMutex       sync.RWMutex
	setXAttrArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
		arg4 int
		arg5 *fuse.Context
	}
	setXAttrReturns struct {
		result1 fuse.Status
	}
	setXAttrReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	StatFsStub        func(string) *fuse.StatfsOut
	statFsMutex       sync.RWMutex
	statFsArgsForCall []struct {
		arg1 string
	}
	statFsReturns struct {
		result1 *fuse.StatfsOut
	}
	statFsReturnsOnCall map[int]struct {
		result1 *fuse.StatfsOut
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
	}
	stringReturns struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	SymlinkStub        func(string, string, *fuse.Context) fuse.Status
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}
	symlinkReturns struct {
		result1 fuse.Status
	}
	symlinkReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	TruncateStub        func(string, uint64, *fuse.Context) fuse.Status
	truncateMutex       sync.RWMutex
	truncateArgsForCall []struct {
		arg1 string
		arg2 uint64
		arg3 *fuse.Context
	}
	truncateReturns struct {
		result1 fuse.Status
	}
	truncateReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	UnlinkStub        func(string, *fuse.Context) fuse.Status
	unlinkMutex       sync.RWMutex
	unlinkArgsForCall []struct {
		arg1 string
		arg2 *fuse.Context
	}
	unlinkReturns struct {
		result1 fuse.Status
	}
	unlinkReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	UtimensStub        func(string, *time.Time, *time.Time, *fuse.Context) fuse.Status
	utimensMutex       sync.RWMutex
	utimensArgsForCall []struct {
		arg1 string
		arg2 *time.Time
		arg3 *time.Time
		arg4 *fuse.Context
	}
	utimensReturns struct {
		result1 fuse.Status
	}
	utimensReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFileSystem) Access(arg1 string, arg2 uint32, arg3 *fuse.Context) fuse.Status {
	fake.accessMutex.Lock()
	ret, specificReturn := fake.accessReturnsOnCall[len(fake.accessArgsForCall)]
	fake.accessArgsForCall = append(fake.accessArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Access", []interface{}{arg1, arg2, arg3})
	fake.accessMutex.Unlock()
	if fake.AccessStub != nil {
		return fake.AccessStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.accessReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) AccessCallCount() int {
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	return len(fake.accessArgsForCall)
}

func (fake *FakeFileSystem) AccessCalls(stub func(string, uint32, *fuse.Context) fuse.Status) {
	fake.accessMutex.Lock()
	defer fake.accessMutex.Unlock()
	fake.AccessStub = stub
}

func (fake *FakeFileSystem) AccessArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	argsForCall := fake.accessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) AccessReturns(result1 fuse.Status) {
	fake.accessMutex.Lock()
	defer fake.accessMutex.Unlock()
	fake.AccessStub = nil
	fake.accessReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) AccessReturnsOnCall(i int, result1 fuse.Status) {
	fake.accessMutex.Lock()
	defer fake.accessMutex.Unlock()
	fake.AccessStub = nil
	if fake.accessReturnsOnCall == nil {
		fake.accessReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.accessReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Chmod(arg1 string, arg2 uint32, arg3 *fuse.Context) fuse.Status {
	fake.chmodMutex.Lock()
	ret, specificReturn := fake.chmodReturnsOnCall[len(fake.chmodArgsForCall)]
	fake.chmodArgsForCall = append(fake.chmodArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Chmod", []interface{}{arg1, arg2, arg3})
	fake.chmodMutex.Unlock()
	if fake.ChmodStub != nil {
		return fake.ChmodStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chmodReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) ChmodCallCount() int {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return len(fake.chmodArgsForCall)
}

func (fake *FakeFileSystem) ChmodCalls(stub func(string, uint32, *fuse.Context) fuse.Status) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = stub
}

func (fake *FakeFileSystem) ChmodArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	argsForCall := fake.chmodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) ChmodReturns(result1 fuse.Status) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	fake.chmodReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) ChmodReturnsOnCall(i int, result1 fuse.Status) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	if fake.chmodReturnsOnCall == nil {
		fake.chmodReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.chmodReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Chown(arg1 string, arg2 uint32, arg3 uint32, arg4 *fuse.Context) fuse.Status {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 uint32
		arg4 *fuse.Context
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Chown", []interface{}{arg1, arg2, arg3, arg4})
	fake.chownMutex.Unlock()
	if fake.ChownStub != nil {
		return fake.ChownStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chownReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeFileSystem) ChownCalls(stub func(string, uint32, uint32, *fuse.Context) fuse.Status) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = stub
}

func (fake *FakeFileSystem) ChownArgsForCall(i int) (string, uint32, uint32, *fuse.Context) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	argsForCall := fake.chownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFileSystem) ChownReturns(result1 fuse.Status) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) ChownReturnsOnCall(i int, result1 fuse.Status) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Create(arg1 string, arg2 uint32, arg3 uint32, arg4 *fuse.Context) (nodefs.File, fuse.Status) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 uint32
		arg4 *fuse.Context
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3, arg4})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeFileSystem) CreateCalls(stub func(string, uint32, uint32, *fuse.Context) (nodefs.File, fuse.Status)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeFileSystem) CreateArgsForCall(i int) (string, uint32, uint32, *fuse.Context) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFileSystem) CreateReturns(result1 nodefs.File, result2 fuse.Status) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) CreateReturnsOnCall(i int, result1 nodefs.File, result2 fuse.Status) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 nodefs.File
			result2 fuse.Status
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) GetAttr(arg1 string, arg2 *fuse.Context) (*fuse.Attr, fuse.Status) {
	fake.getAttrMutex.Lock()
	ret, specificReturn := fake.getAttrReturnsOnCall[len(fake.getAttrArgsForCall)]
	fake.getAttrArgsForCall = append(fake.getAttrArgsForCall, struct {
		arg1 string
		arg2 *fuse.Context
	}{arg1, arg2})
	fake.recordInvocation("GetAttr", []interface{}{arg1, arg2})
	fake.getAttrMutex.Unlock()
	if fake.GetAttrStub != nil {
		return fake.GetAttrStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAttrReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) GetAttrCallCount() int {
	fake.getAttrMutex.RLock()
	defer fake.getAttrMutex.RUnlock()
	return len(fake.getAttrArgsForCall)
}

func (fake *FakeFileSystem) GetAttrCalls(stub func(string, *fuse.Context) (*fuse.Attr, fuse.Status)) {
	fake.getAttrMutex.Lock()
	defer fake.getAttrMutex.Unlock()
	fake.GetAttrStub = stub
}

func (fake *FakeFileSystem) GetAttrArgsForCall(i int) (string, *fuse.Context) {
	fake.getAttrMutex.RLock()
	defer fake.getAttrMutex.RUnlock()
	argsForCall := fake.getAttrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) GetAttrReturns(result1 *fuse.Attr, result2 fuse.Status) {
	fake.getAttrMutex.Lock()
	defer fake.getAttrMutex.Unlock()
	fake.GetAttrStub = nil
	fake.getAttrReturns = struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) GetAttrReturnsOnCall(i int, result1 *fuse.Attr, result2 fuse.Status) {
	fake.getAttrMutex.Lock()
	defer fake.getAttrMutex.Unlock()
	fake.GetAttrStub = nil
	if fake.getAttrReturnsOnCall == nil {
		fake.getAttrReturnsOnCall = make(map[int]struct {
			result1 *fuse.Attr
			result2 fuse.Status
		})
	}
	fake.getAttrReturnsOnCall[i] = struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) GetXAttr(arg1 string, arg2 string, arg3 *fuse.Context) ([]byte, fuse.Status) {
	fake.getXAttrMutex.Lock()
	ret, specificReturn := fake.getXAttrReturnsOnCall[len(fake.getXAttrArgsForCall)]
	fake.getXAttrArgsForCall = append(fake.getXAttrArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetXAttr", []interface{}{arg1, arg2, arg3})
	fake.getXAttrMutex.Unlock()
	if fake.GetXAttrStub != nil {
		return fake.GetXAttrStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getXAttrReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) GetXAttrCallCount() int {
	fake.getXAttrMutex.RLock()
	defer fake.getXAttrMutex.RUnlock()
	return len(fake.getXAttrArgsForCall)
}

func (fake *FakeFileSystem) GetXAttrCalls(stub func(string, string, *fuse.Context) ([]byte, fuse.Status)) {
	fake.getXAttrMutex.Lock()
	defer fake.getXAttrMutex.Unlock()
	fake.GetXAttrStub = stub
}

func (fake *FakeFileSystem) GetXAttrArgsForCall(i int) (string, string, *fuse.Context) {
	fake.getXAttrMutex.RLock()
	defer fake.getXAttrMutex.RUnlock()
	argsForCall := fake.getXAttrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) GetXAttrReturns(result1 []byte, result2 fuse.Status) {
	fake.getXAttrMutex.Lock()
	defer fake.getXAttrMutex.Unlock()
	fake.GetXAttrStub = nil
	fake.getXAttrReturns = struct {
		result1 []byte
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) GetXAttrReturnsOnCall(i int, result1 []byte, result2 fuse.Status) {
	fake.getXAttrMutex.Lock()
	defer fake.getXAttrMutex.Unlock()
	fake.GetXAttrStub = nil
	if fake.getXAttrReturnsOnCall == nil {
		fake.getXAttrReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 fuse.Status
		})
	}
	fake.getXAttrReturnsOnCall[i] = struct {
		result1 []byte
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) Link(arg1 string, arg2 string, arg3 *fuse.Context) fuse.Status {
	fake.linkMutex.Lock()
	ret, specificReturn := fake.linkReturnsOnCall[len(fake.linkArgsForCall)]
	fake.linkArgsForCall = append(fake.linkArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Link", []interface{}{arg1, arg2, arg3})
	fake.linkMutex.Unlock()
	if fake.LinkStub != nil {
		return fake.LinkStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.linkReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) LinkCallCount() int {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return len(fake.linkArgsForCall)
}

func (fake *FakeFileSystem) LinkCalls(stub func(string, string, *fuse.Context) fuse.Status) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = stub
}

func (fake *FakeFileSystem) LinkArgsForCall(i int) (string, string, *fuse.Context) {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	argsForCall := fake.linkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) LinkReturns(result1 fuse.Status) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	fake.linkReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) LinkReturnsOnCall(i int, result1 fuse.Status) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	if fake.linkReturnsOnCall == nil {
		fake.linkReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.linkReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) ListXAttr(arg1 string, arg2 *fuse.Context) ([]string, fuse.Status) {
	fake.listXAttrMutex.Lock()
	ret, specificReturn := fake.listXAttrReturnsOnCall[len(fake.listXAttrArgsForCall)]
	fake.listXAttrArgsForCall = append(fake.listXAttrArgsForCall, struct {
		arg1 string
		arg2 *fuse.Context
	}{arg1, arg2})
	fake.recordInvocation("ListXAttr", []interface{}{arg1, arg2})
	fake.listXAttrMutex.Unlock()
	if fake.ListXAttrStub != nil {
		return fake.ListXAttrStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listXAttrReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ListXAttrCallCount() int {
	fake.listXAttrMutex.RLock()
	defer fake.listXAttrMutex.RUnlock()
	return len(fake.listXAttrArgsForCall)
}

func (fake *FakeFileSystem) ListXAttrCalls(stub func(string, *fuse.Context) ([]string, fuse.Status)) {
	fake.listXAttrMutex.Lock()
	defer fake.listXAttrMutex.Unlock()
	fake.ListXAttrStub = stub
}

func (fake *FakeFileSystem) ListXAttrArgsForCall(i int) (string, *fuse.Context) {
	fake.listXAttrMutex.RLock()
	defer fake.listXAttrMutex.RUnlock()
	argsForCall := fake.listXAttrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) ListXAttrReturns(result1 []string, result2 fuse.Status) {
	fake.listXAttrMutex.Lock()
	defer fake.listXAttrMutex.Unlock()
	fake.ListXAttrStub = nil
	fake.listXAttrReturns = struct {
		result1 []string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) ListXAttrReturnsOnCall(i int, result1 []string, result2 fuse.Status) {
	fake.listXAttrMutex.Lock()
	defer fake.listXAttrMutex.Unlock()
	fake.ListXAttrStub = nil
	if fake.listXAttrReturnsOnCall == nil {
		fake.listXAttrReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 fuse.Status
		})
	}
	fake.listXAttrReturnsOnCall[i] = struct {
		result1 []string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) Mkdir(arg1 string, arg2 uint32, arg3 *fuse.Context) fuse.Status {
	fake.mkdirMutex.Lock()
	ret, specificReturn := fake.mkdirReturnsOnCall[len(fake.mkdirArgsForCall)]
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Mkdir", []interface{}{arg1, arg2, arg3})
	fake.mkdirMutex.Unlock()
	if fake.MkdirStub != nil {
		return fake.MkdirStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mkdirReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeFileSystem) MkdirCalls(stub func(string, uint32, *fuse.Context) fuse.Status) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = stub
}

func (fake *FakeFileSystem) MkdirArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	argsForCall := fake.mkdirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) MkdirReturns(result1 fuse.Status) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) MkdirReturnsOnCall(i int, result1 fuse.Status) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	if fake.mkdirReturnsOnCall == nil {
		fake.mkdirReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.mkdirReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Mknod(arg1 string, arg2 uint32, arg3 uint32, arg4 *fuse.Context) fuse.Status {
	fake.mknodMutex.Lock()
	ret, specificReturn := fake.mknodReturnsOnCall[len(fake.mknodArgsForCall)]
	fake.mknodArgsForCall = append(fake.mknodArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 uint32
		arg4 *fuse.Context
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Mknod", []interface{}{arg1, arg2, arg3, arg4})
	fake.mknodMutex.Unlock()
	if fake.MknodStub != nil {
		return fake.MknodStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mknodReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) MknodCallCount() int {
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	return len(fake.mknodArgsForCall)
}

func (fake *FakeFileSystem) MknodCalls(stub func(string, uint32, uint32, *fuse.Context) fuse.Status) {
	fake.mknodMutex.Lock()
	defer fake.mknodMutex.Unlock()
	fake.MknodStub = stub
}

func (fake *FakeFileSystem) MknodArgsForCall(i int) (string, uint32, uint32, *fuse.Context) {
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	argsForCall := fake.mknodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFileSystem) MknodReturns(result1 fuse.Status) {
	fake.mknodMutex.Lock()
	defer fake.mknodMutex.Unlock()
	fake.MknodStub = nil
	fake.mknodReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) MknodReturnsOnCall(i int, result1 fuse.Status) {
	fake.mknodMutex.Lock()
	defer fake.mknodMutex.Unlock()
	fake.MknodStub = nil
	if fake.mknodReturnsOnCall == nil {
		fake.mknodReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.mknodReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) OnMount(arg1 *pathfs.PathNodeFs) {
	fake.onMountMutex.Lock()
	fake.onMountArgsForCall = append(fake.onMountArgsForCall, struct {
		arg1 *pathfs.PathNodeFs
	}{arg1})
	fake.recordInvocation("OnMount", []interface{}{arg1})
	fake.onMountMutex.Unlock()
	if fake.OnMountStub != nil {
		fake.OnMountStub(arg1)
	}
}

func (fake *FakeFileSystem) OnMountCallCount() int {
	fake.onMountMutex.RLock()
	defer fake.onMountMutex.RUnlock()
	return len(fake.onMountArgsForCall)
}

func (fake *FakeFileSystem) OnMountCalls(stub func(*pathfs.PathNodeFs)) {
	fake.onMountMutex.Lock()
	defer fake.onMountMutex.Unlock()
	fake.OnMountStub = stub
}

func (fake *FakeFileSystem) OnMountArgsForCall(i int) *pathfs.PathNodeFs {
	fake.onMountMutex.RLock()
	defer fake.onMountMutex.RUnlock()
	argsForCall := fake.onMountArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) OnUnmount() {
	fake.onUnmountMutex.Lock()
	fake.onUnmountArgsForCall = append(fake.onUnmountArgsForCall, struct {
	}{})
	fake.recordInvocation("OnUnmount", []interface{}{})
	fake.onUnmountMutex.Unlock()
	if fake.OnUnmountStub != nil {
		fake.OnUnmountStub()
	}
}

func (fake *FakeFileSystem) OnUnmountCallCount() int {
	fake.onUnmountMutex.RLock()
	defer fake.onUnmountMutex.RUnlock()
	return len(fake.onUnmountArgsForCall)
}

func (fake *FakeFileSystem) OnUnmountCalls(stub func()) {
	fake.onUnmountMutex.Lock()
	defer fake.onUnmountMutex.Unlock()
	fake.OnUnmountStub = stub
}

func (fake *FakeFileSystem) Open(arg1 string, arg2 uint32, arg3 *fuse.Context) (nodefs.File, fuse.Status) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Open", []interface{}{arg1, arg2, arg3})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.openReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeFileSystem) OpenCalls(stub func(string, uint32, *fuse.Context) (nodefs.File, fuse.Status)) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeFileSystem) OpenArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) OpenReturns(result1 nodefs.File, result2 fuse.Status) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) OpenReturnsOnCall(i int, result1 nodefs.File, result2 fuse.Status) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 nodefs.File
			result2 fuse.Status
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) OpenDir(arg1 string, arg2 *fuse.Context) ([]fuse.DirEntry, fuse.Status) {
	fake.openDirMutex.Lock()
	ret, specificReturn := fake.openDirReturnsOnCall[len(fake.openDirArgsForCall)]
	fake.openDirArgsForCall = append(fake.openDirArgsForCall, struct {
		arg1 string
		arg2 *fuse.Context
	}{arg1, arg2})
	fake.recordInvocation("OpenDir", []interface{}{arg1, arg2})
	fake.openDirMutex.Unlock()
	if fake.OpenDirStub != nil {
		return fake.OpenDirStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.openDirReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) OpenDirCallCount() int {
	fake.openDirMutex.RLock()
	defer fake.openDirMutex.RUnlock()
	return len(fake.openDirArgsForCall)
}

func (fake *FakeFileSystem) OpenDirCalls(stub func(string, *fuse.Context) ([]fuse.DirEntry, fuse.Status)) {
	fake.openDirMutex.Lock()
	defer fake.openDirMutex.Unlock()
	fake.OpenDirStub = stub
}

func (fake *FakeFileSystem) OpenDirArgsForCall(i int) (string, *fuse.Context) {
	fake.openDirMutex.RLock()
	defer fake.openDirMutex.RUnlock()
	argsForCall := fake.openDirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) OpenDirReturns(result1 []fuse.DirEntry, result2 fuse.Status) {
	fake.openDirMutex.Lock()
	defer fake.openDirMutex.Unlock()
	fake.OpenDirStub = nil
	fake.openDirReturns = struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) OpenDirReturnsOnCall(i int, result1 []fuse.DirEntry, result2 fuse.Status) {
	fake.openDirMutex.Lock()
	defer fake.openDirMutex.Unlock()
	fake.OpenDirStub = nil
	if fake.openDirReturnsOnCall == nil {
		fake.openDirReturnsOnCall = make(map[int]struct {
			result1 []fuse.DirEntry
			result2 fuse.Status
		})
	}
	fake.openDirReturnsOnCall[i] = struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) Readlink(arg1 string, arg2 *fuse.Context) (string, fuse.Status) {
	fake.readlinkMutex.Lock()
	ret, specificReturn := fake.readlinkReturnsOnCall[len(fake.readlinkArgsForCall)]
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		arg1 string
		arg2 *fuse.Context
	}{arg1, arg2})
	fake.recordInvocation("Readlink", []interface{}{arg1, arg2})
	fake.readlinkMutex.Unlock()
	if fake.ReadlinkStub != nil {
		return fake.ReadlinkStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readlinkReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeFileSystem) ReadlinkCalls(stub func(string, *fuse.Context) (string, fuse.Status)) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = stub
}

func (fake *FakeFileSystem) ReadlinkArgsForCall(i int) (string, *fuse.Context) {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	argsForCall := fake.readlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) ReadlinkReturns(result1 string, result2 fuse.Status) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadlinkReturnsOnCall(i int, result1 string, result2 fuse.Status) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	if fake.readlinkReturnsOnCall == nil {
		fake.readlinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 fuse.Status
		})
	}
	fake.readlinkReturnsOnCall[i] = struct {
		result1 string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) RemoveXAttr(arg1 string, arg2 string, arg3 *fuse.Context) fuse.Status {
	fake.removeXAttrMutex.Lock()
	ret, specificReturn := fake.removeXAttrReturnsOnCall[len(fake.removeXAttrArgsForCall)]
	fake.removeXAttrArgsForCall = append(fake.removeXAttrArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveXAttr", []interface{}{arg1, arg2, arg3})
	fake.removeXAttrMutex.Unlock()
	if fake.RemoveXAttrStub != nil {
		return fake.RemoveXAttrStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeXAttrReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) RemoveXAttrCallCount() int {
	fake.removeXAttrMutex.RLock()
	defer fake.removeXAttrMutex.RUnlock()
	return len(fake.removeXAttrArgsForCall)
}

func (fake *FakeFileSystem) RemoveXAttrCalls(stub func(string, string, *fuse.Context) fuse.Status) {
	fake.removeXAttrMutex.Lock()
	defer fake.removeXAttrMutex.Unlock()
	fake.RemoveXAttrStub = stub
}

func (fake *FakeFileSystem) RemoveXAttrArgsForCall(i int) (string, string, *fuse.Context) {
	fake.removeXAttrMutex.RLock()
	defer fake.removeXAttrMutex.RUnlock()
	argsForCall := fake.removeXAttrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) RemoveXAttrReturns(result1 fuse.Status) {
	fake.removeXAttrMutex.Lock()
	defer fake.removeXAttrMutex.Unlock()
	fake.RemoveXAttrStub = nil
	fake.removeXAttrReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) RemoveXAttrReturnsOnCall(i int, result1 fuse.Status) {
	fake.removeXAttrMutex.Lock()
	defer fake.removeXAttrMutex.Unlock()
	fake.RemoveXAttrStub = nil
	if fake.removeXAttrReturnsOnCall == nil {
		fake.removeXAttrReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.removeXAttrReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Rename(arg1 string, arg2 string, arg3 *fuse.Context) fuse.Status {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Rename", []interface{}{arg1, arg2, arg3})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renameReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeFileSystem) RenameCalls(stub func(string, string, *fuse.Context) fuse.Status) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakeFileSystem) RenameArgsForCall(i int) (string, string, *fuse.Context) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) RenameReturns(result1 fuse.Status) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) RenameReturnsOnCall(i int, result1 fuse.Status) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Rmdir(arg1 string, arg2 *fuse.Context) fuse.Status {
	fake.rmdirMutex.Lock()
	ret, specificReturn := fake.rmdirReturnsOnCall[len(fake.rmdirArgsForCall)]
	fake.rmdirArgsForCall = append(fake.rmdirArgsForCall, struct {
		arg1 string
		arg2 *fuse.Context
	}{arg1, arg2})
	fake.recordInvocation("Rmdir", []interface{}{arg1, arg2})
	fake.rmdirMutex.Unlock()
	if fake.RmdirStub != nil {
		return fake.RmdirStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rmdirReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) RmdirCallCount() int {
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	return len(fake.rmdirArgsForCall)
}

func (fake *FakeFileSystem) RmdirCalls(stub func(string, *fuse.Context) fuse.Status) {
	fake.rmdirMutex.Lock()
	defer fake.rmdirMutex.Unlock()
	fake.RmdirStub = stub
}

func (fake *FakeFileSystem) RmdirArgsForCall(i int) (string, *fuse.Context) {
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	argsForCall := fake.rmdirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) RmdirReturns(result1 fuse.Status) {
	fake.rmdirMutex.Lock()
	defer fake.rmdirMutex.Unlock()
	fake.RmdirStub = nil
	fake.rmdirReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) RmdirReturnsOnCall(i int, result1 fuse.Status) {
	fake.rmdirMutex.Lock()
	defer fake.rmdirMutex.Unlock()
	fake.RmdirStub = nil
	if fake.rmdirReturnsOnCall == nil {
		fake.rmdirReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.rmdirReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) SetDebug(arg1 bool) {
	fake.setDebugMutex.Lock()
	fake.setDebugArgsForCall = append(fake.setDebugArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetDebug", []interface{}{arg1})
	fake.setDebugMutex.Unlock()
	if fake.SetDebugStub != nil {
		fake.SetDebugStub(arg1)
	}
}

func (fake *FakeFileSystem) SetDebugCallCount() int {
	fake.setDebugMutex.RLock()
	defer fake.setDebugMutex.RUnlock()
	return len(fake.setDebugArgsForCall)
}

func (fake *FakeFileSystem) SetDebugCalls(stub func(bool)) {
	fake.setDebugMutex.Lock()
	defer fake.setDebugMutex.Unlock()
	fake.SetDebugStub = stub
}

func (fake *FakeFileSystem) SetDebugArgsForCall(i int) bool {
	fake.setDebugMutex.RLock()
	defer fake.setDebugMutex.RUnlock()
	argsForCall := fake.setDebugArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) SetXAttr(arg1 string, arg2 string, arg3 []byte, arg4 int, arg5 *fuse.Context) fuse.Status {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.setXAttrMutex.Lock()
	ret, specificReturn := fake.setXAttrReturnsOnCall[len(fake.setXAttrArgsForCall)]
	fake.setXAttrArgsForCall = append(fake.setXAttrArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
		arg4 int
		arg5 *fuse.Context
	}{arg1, arg2, arg3Copy, arg4, arg5})
	fake.recordInvocation("SetXAttr", []interface{}{arg1, arg2, arg3Copy, arg4, arg5})
	fake.setXAttrMutex.Unlock()
	if fake.SetXAttrStub != nil {
		return fake.SetXAttrStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setXAttrReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) SetXAttrCallCount() int {
	fake.setXAttrMutex.RLock()
	defer fake.setXAttrMutex.RUnlock()
	return len(fake.setXAttrArgsForCall)
}

func (fake *FakeFileSystem) SetXAttrCalls(stub func(string, string, []byte, int, *fuse.Context) fuse.Status) {
	fake.setXAttrMutex.Lock()
	defer fake.setXAttrMutex.Unlock()
	fake.SetXAttrStub = stub
}

func (fake *FakeFileSystem) SetXAttrArgsForCall(i int) (string, string, []byte, int, *fuse.Context) {
	fake.setXAttrMutex.RLock()
	defer fake.setXAttrMutex.RUnlock()
	argsForCall := fake.setXAttrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeFileSystem) SetXAttrReturns(result1 fuse.Status) {
	fake.setXAttrMutex.Lock()
	defer fake.setXAttrMutex.Unlock()
	fake.SetXAttrStub = nil
	fake.setXAttrReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) SetXAttrReturnsOnCall(i int, result1 fuse.Status) {
	fake.setXAttrMutex.Lock()
	defer fake.setXAttrMutex.Unlock()
	fake.SetXAttrStub = nil
	if fake.setXAttrReturnsOnCall == nil {
		fake.setXAttrReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.setXAttrReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) StatFs(arg1 string) *fuse.StatfsOut {
	fake.statFsMutex.Lock()
	ret, specificReturn := fake.statFsReturnsOnCall[len(fake.statFsArgsForCall)]
	fake.statFsArgsForCall = append(fake.statFsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("StatFs", []interface{}{arg1})
	fake.statFsMutex.Unlock()
	if fake.StatFsStub != nil {
		return fake.StatFsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.statFsReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) StatFsCallCount() int {
	fake.statFsMutex.RLock()
	defer fake.statFsMutex.RUnlock()
	return len(fake.statFsArgsForCall)
}

func (fake *FakeFileSystem) StatFsCalls(stub func(string) *fuse.StatfsOut) {
	fake.statFsMutex.Lock()
	defer fake.statFsMutex.Unlock()
	fake.StatFsStub = stub
}

func (fake *FakeFileSystem) StatFsArgsForCall(i int) string {
	fake.statFsMutex.RLock()
	defer fake.statFsMutex.RUnlock()
	argsForCall := fake.statFsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) StatFsReturns(result1 *fuse.StatfsOut) {
	fake.statFsMutex.Lock()
	defer fake.statFsMutex.Unlock()
	fake.StatFsStub = nil
	fake.statFsReturns = struct {
		result1 *fuse.StatfsOut
	}{result1}
}

func (fake *FakeFileSystem) StatFsReturnsOnCall(i int, result1 *fuse.StatfsOut) {
	fake.statFsMutex.Lock()
	defer fake.statFsMutex.Unlock()
	fake.StatFsStub = nil
	if fake.statFsReturnsOnCall == nil {
		fake.statFsReturnsOnCall = make(map[int]struct {
			result1 *fuse.StatfsOut
		})
	}
	fake.statFsReturnsOnCall[i] = struct {
		result1 *fuse.StatfsOut
	}{result1}
}

func (fake *FakeFileSystem) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
	}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stringReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeFileSystem) StringCalls(stub func() string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *FakeFileSystem) StringReturns(result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFileSystem) StringReturnsOnCall(i int, result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFileSystem) Symlink(arg1 string, arg2 string, arg3 *fuse.Context) fuse.Status {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Symlink", []interface{}{arg1, arg2, arg3})
	fake.symlinkMutex.Unlock()
	if fake.SymlinkStub != nil {
		return fake.SymlinkStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.symlinkReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeFileSystem) SymlinkCalls(stub func(string, string, *fuse.Context) fuse.Status) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = stub
}

func (fake *FakeFileSystem) SymlinkArgsForCall(i int) (string, string, *fuse.Context) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	argsForCall := fake.symlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) SymlinkReturns(result1 fuse.Status) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) SymlinkReturnsOnCall(i int, result1 fuse.Status) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Truncate(arg1 string, arg2 uint64, arg3 *fuse.Context) fuse.Status {
	fake.truncateMutex.Lock()
	ret, specificReturn := fake.truncateReturnsOnCall[len(fake.truncateArgsForCall)]
	fake.truncateArgsForCall = append(fake.truncateArgsForCall, struct {
		arg1 string
		arg2 uint64
		arg3 *fuse.Context
	}{arg1, arg2, arg3})
	fake.recordInvocation("Truncate", []interface{}{arg1, arg2, arg3})
	fake.truncateMutex.Unlock()
	if fake.TruncateStub != nil {
		return fake.TruncateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.truncateReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) TruncateCallCount() int {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return len(fake.truncateArgsForCall)
}

func (fake *FakeFileSystem) TruncateCalls(stub func(string, uint64, *fuse.Context) fuse.Status) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = stub
}

func (fake *FakeFileSystem) TruncateArgsForCall(i int) (string, uint64, *fuse.Context) {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	argsForCall := fake.truncateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) TruncateReturns(result1 fuse.Status) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	fake.truncateReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) TruncateReturnsOnCall(i int, result1 fuse.Status) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	if fake.truncateReturnsOnCall == nil {
		fake.truncateReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.truncateReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Unlink(arg1 string, arg2 *fuse.Context) fuse.Status {
	fake.unlinkMutex.Lock()
	ret, specificReturn := fake.unlinkReturnsOnCall[len(fake.unlinkArgsForCall)]
	fake.unlinkArgsForCall = append(fake.unlinkArgsForCall, struct {
		arg1 string
		arg2 *fuse.Context
	}{arg1, arg2})
	fake.recordInvocation("Unlink", []interface{}{arg1, arg2})
	fake.unlinkMutex.Unlock()
	if fake.UnlinkStub != nil {
		return fake.UnlinkStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unlinkReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) UnlinkCallCount() int {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	return len(fake.unlinkArgsForCall)
}

func (fake *FakeFileSystem) UnlinkCalls(stub func(string, *fuse.Context) fuse.Status) {
	fake.unlinkMutex.Lock()
	defer fake.unlinkMutex.Unlock()
	fake.UnlinkStub = stub
}

func (fake *FakeFileSystem) UnlinkArgsForCall(i int) (string, *fuse.Context) {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	argsForCall := fake.unlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) UnlinkReturns(result1 fuse.Status) {
	fake.unlinkMutex.Lock()
	defer fake.unlinkMutex.Unlock()
	fake.UnlinkStub = nil
	fake.unlinkReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) UnlinkReturnsOnCall(i int, result1 fuse.Status) {
	fake.unlinkMutex.Lock()
	defer fake.unlinkMutex.Unlock()
	fake.UnlinkStub = nil
	if fake.unlinkReturnsOnCall == nil {
		fake.unlinkReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.unlinkReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Utimens(arg1 string, arg2 *time.Time, arg3 *time.Time, arg4 *fuse.Context) fuse.Status {
	fake.utimensMutex.Lock()
	ret, specificReturn := fake.utimensReturnsOnCall[len(fake.utimensArgsForCall)]
	fake.utimensArgsForCall = append(fake.utimensArgsForCall, struct {
		arg1 string
		arg2 *time.Time
		arg3 *time.Time
		arg4 *fuse.Context
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Utimens", []interface{}{arg1, arg2, arg3, arg4})
	fake.utimensMutex.Unlock()
	if fake.UtimensStub != nil {
		return fake.UtimensStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.utimensReturns
	return fakeReturns.result1
}

func (fake *FakeFileSystem) UtimensCallCount() int {
	fake.utimensMutex.RLock()
	defer fake.utimensMutex.RUnlock()
	return len(fake.utimensArgsForCall)
}

func (fake *FakeFileSystem) UtimensCalls(stub func(string, *time.Time, *time.Time, *fuse.Context) fuse.Status) {
	fake.utimensMutex.Lock()
	defer fake.utimensMutex.Unlock()
	fake.UtimensStub = stub
}

func (fake *FakeFileSystem) UtimensArgsForCall(i int) (string, *time.Time, *time.Time, *fuse.Context) {
	fake.utimensMutex.RLock()
	defer fake.utimensMutex.RUnlock()
	argsForCall := fake.utimensArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFileSystem) UtimensReturns(result1 fuse.Status) {
	fake.utimensMutex.Lock()
	defer fake.utimensMutex.Unlock()
	fake.UtimensStub = nil
	fake.utimensReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) UtimensReturnsOnCall(i int, result1 fuse.Status) {
	fake.utimensMutex.Lock()
	defer fake.utimensMutex.Unlock()
	fake.UtimensStub = nil
	if fake.utimensReturnsOnCall == nil {
		fake.utimensReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.utimensReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.getAttrMutex.RLock()
	defer fake.getAttrMutex.RUnlock()
	fake.getXAttrMutex.RLock()
	defer fake.getXAttrMutex.RUnlock()
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	fake.listXAttrMutex.RLock()
	defer fake.listXAttrMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	fake.onMountMutex.RLock()
	defer fake.onMountMutex.RUnlock()
	fake.onUnmountMutex.RLock()
	defer fake.onUnmountMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.openDirMutex.RLock()
	defer fake.openDirMutex.RUnlock()
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	fake.removeXAttrMutex.RLock()
	defer fake.removeXAttrMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	fake.setDebugMutex.RLock()
	defer fake.setDebugMutex.RUnlock()
	fake.setXAttrMutex.RLock()
	defer fake.setXAttrMutex.RUnlock()
	fake.statFsMutex.RLock()
	defer fake.statFsMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	fake.utimensMutex.RLock()
	defer fake.utimensMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFileSystem) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pathfs.FileSystem = new(FakeFileSystem)
