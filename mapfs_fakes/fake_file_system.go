// Code generated by counterfeiter. DO NOT EDIT.
package mapfs_fakes

import (
	"sync"
	"time"

	"github.com/hanwen/go-fuse/fuse"
	"github.com/hanwen/go-fuse/fuse/nodefs"
	"github.com/hanwen/go-fuse/fuse/pathfs"
)

type FakeFileSystem struct {
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct{}
	stringReturns     struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	SetDebugStub        func(debug bool)
	setDebugMutex       sync.RWMutex
	setDebugArgsForCall []struct {
		debug bool
	}
	GetAttrStub        func(name string, context *fuse.Context) (*fuse.Attr, fuse.Status)
	getAttrMutex       sync.RWMutex
	getAttrArgsForCall []struct {
		name    string
		context *fuse.Context
	}
	getAttrReturns struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}
	getAttrReturnsOnCall map[int]struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}
	ChmodStub        func(name string, mode uint32, context *fuse.Context) (code fuse.Status)
	chmodMutex       sync.RWMutex
	chmodArgsForCall []struct {
		name    string
		mode    uint32
		context *fuse.Context
	}
	chmodReturns struct {
		result1 fuse.Status
	}
	chmodReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	ChownStub        func(name string, uid uint32, gid uint32, context *fuse.Context) (code fuse.Status)
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		name    string
		uid     uint32
		gid     uint32
		context *fuse.Context
	}
	chownReturns struct {
		result1 fuse.Status
	}
	chownReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	UtimensStub        func(name string, Atime *time.Time, Mtime *time.Time, context *fuse.Context) (code fuse.Status)
	utimensMutex       sync.RWMutex
	utimensArgsForCall []struct {
		name    string
		Atime   *time.Time
		Mtime   *time.Time
		context *fuse.Context
	}
	utimensReturns struct {
		result1 fuse.Status
	}
	utimensReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	TruncateStub        func(name string, size uint64, context *fuse.Context) (code fuse.Status)
	truncateMutex       sync.RWMutex
	truncateArgsForCall []struct {
		name    string
		size    uint64
		context *fuse.Context
	}
	truncateReturns struct {
		result1 fuse.Status
	}
	truncateReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	AccessStub        func(name string, mode uint32, context *fuse.Context) (code fuse.Status)
	accessMutex       sync.RWMutex
	accessArgsForCall []struct {
		name    string
		mode    uint32
		context *fuse.Context
	}
	accessReturns struct {
		result1 fuse.Status
	}
	accessReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	LinkStub        func(oldName string, newName string, context *fuse.Context) (code fuse.Status)
	linkMutex       sync.RWMutex
	linkArgsForCall []struct {
		oldName string
		newName string
		context *fuse.Context
	}
	linkReturns struct {
		result1 fuse.Status
	}
	linkReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	MkdirStub        func(name string, mode uint32, context *fuse.Context) fuse.Status
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		name    string
		mode    uint32
		context *fuse.Context
	}
	mkdirReturns struct {
		result1 fuse.Status
	}
	mkdirReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	MknodStub        func(name string, mode uint32, dev uint32, context *fuse.Context) fuse.Status
	mknodMutex       sync.RWMutex
	mknodArgsForCall []struct {
		name    string
		mode    uint32
		dev     uint32
		context *fuse.Context
	}
	mknodReturns struct {
		result1 fuse.Status
	}
	mknodReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	RenameStub        func(oldName string, newName string, context *fuse.Context) (code fuse.Status)
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		oldName string
		newName string
		context *fuse.Context
	}
	renameReturns struct {
		result1 fuse.Status
	}
	renameReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	RmdirStub        func(name string, context *fuse.Context) (code fuse.Status)
	rmdirMutex       sync.RWMutex
	rmdirArgsForCall []struct {
		name    string
		context *fuse.Context
	}
	rmdirReturns struct {
		result1 fuse.Status
	}
	rmdirReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	UnlinkStub        func(name string, context *fuse.Context) (code fuse.Status)
	unlinkMutex       sync.RWMutex
	unlinkArgsForCall []struct {
		name    string
		context *fuse.Context
	}
	unlinkReturns struct {
		result1 fuse.Status
	}
	unlinkReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	GetXAttrStub        func(name string, attribute string, context *fuse.Context) (data []byte, code fuse.Status)
	getXAttrMutex       sync.RWMutex
	getXAttrArgsForCall []struct {
		name      string
		attribute string
		context   *fuse.Context
	}
	getXAttrReturns struct {
		result1 []byte
		result2 fuse.Status
	}
	getXAttrReturnsOnCall map[int]struct {
		result1 []byte
		result2 fuse.Status
	}
	ListXAttrStub        func(name string, context *fuse.Context) (attributes []string, code fuse.Status)
	listXAttrMutex       sync.RWMutex
	listXAttrArgsForCall []struct {
		name    string
		context *fuse.Context
	}
	listXAttrReturns struct {
		result1 []string
		result2 fuse.Status
	}
	listXAttrReturnsOnCall map[int]struct {
		result1 []string
		result2 fuse.Status
	}
	RemoveXAttrStub        func(name string, attr string, context *fuse.Context) fuse.Status
	removeXAttrMutex       sync.RWMutex
	removeXAttrArgsForCall []struct {
		name    string
		attr    string
		context *fuse.Context
	}
	removeXAttrReturns struct {
		result1 fuse.Status
	}
	removeXAttrReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	SetXAttrStub        func(name string, attr string, data []byte, flags int, context *fuse.Context) fuse.Status
	setXAttrMutex       sync.RWMutex
	setXAttrArgsForCall []struct {
		name    string
		attr    string
		data    []byte
		flags   int
		context *fuse.Context
	}
	setXAttrReturns struct {
		result1 fuse.Status
	}
	setXAttrReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	OnMountStub        func(nodeFs *pathfs.PathNodeFs)
	onMountMutex       sync.RWMutex
	onMountArgsForCall []struct {
		nodeFs *pathfs.PathNodeFs
	}
	OnUnmountStub        func()
	onUnmountMutex       sync.RWMutex
	onUnmountArgsForCall []struct{}
	OpenStub             func(name string, flags uint32, context *fuse.Context) (file nodefs.File, code fuse.Status)
	openMutex            sync.RWMutex
	openArgsForCall      []struct {
		name    string
		flags   uint32
		context *fuse.Context
	}
	openReturns struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	openReturnsOnCall map[int]struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	CreateStub        func(name string, flags uint32, mode uint32, context *fuse.Context) (file nodefs.File, code fuse.Status)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		name    string
		flags   uint32
		mode    uint32
		context *fuse.Context
	}
	createReturns struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	createReturnsOnCall map[int]struct {
		result1 nodefs.File
		result2 fuse.Status
	}
	OpenDirStub        func(name string, context *fuse.Context) (stream []fuse.DirEntry, code fuse.Status)
	openDirMutex       sync.RWMutex
	openDirArgsForCall []struct {
		name    string
		context *fuse.Context
	}
	openDirReturns struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}
	openDirReturnsOnCall map[int]struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}
	SymlinkStub        func(value string, linkName string, context *fuse.Context) (code fuse.Status)
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		value    string
		linkName string
		context  *fuse.Context
	}
	symlinkReturns struct {
		result1 fuse.Status
	}
	symlinkReturnsOnCall map[int]struct {
		result1 fuse.Status
	}
	ReadlinkStub        func(name string, context *fuse.Context) (string, fuse.Status)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		name    string
		context *fuse.Context
	}
	readlinkReturns struct {
		result1 string
		result2 fuse.Status
	}
	readlinkReturnsOnCall map[int]struct {
		result1 string
		result2 fuse.Status
	}
	StatFsStub        func(name string) *fuse.StatfsOut
	statFsMutex       sync.RWMutex
	statFsArgsForCall []struct {
		name string
	}
	statFsReturns struct {
		result1 *fuse.StatfsOut
	}
	statFsReturnsOnCall map[int]struct {
		result1 *fuse.StatfsOut
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFileSystem) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct{}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringReturns.result1
}

func (fake *FakeFileSystem) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeFileSystem) StringReturns(result1 string) {
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFileSystem) StringReturnsOnCall(i int, result1 string) {
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFileSystem) SetDebug(debug bool) {
	fake.setDebugMutex.Lock()
	fake.setDebugArgsForCall = append(fake.setDebugArgsForCall, struct {
		debug bool
	}{debug})
	fake.recordInvocation("SetDebug", []interface{}{debug})
	fake.setDebugMutex.Unlock()
	if fake.SetDebugStub != nil {
		fake.SetDebugStub(debug)
	}
}

func (fake *FakeFileSystem) SetDebugCallCount() int {
	fake.setDebugMutex.RLock()
	defer fake.setDebugMutex.RUnlock()
	return len(fake.setDebugArgsForCall)
}

func (fake *FakeFileSystem) SetDebugArgsForCall(i int) bool {
	fake.setDebugMutex.RLock()
	defer fake.setDebugMutex.RUnlock()
	return fake.setDebugArgsForCall[i].debug
}

func (fake *FakeFileSystem) GetAttr(name string, context *fuse.Context) (*fuse.Attr, fuse.Status) {
	fake.getAttrMutex.Lock()
	ret, specificReturn := fake.getAttrReturnsOnCall[len(fake.getAttrArgsForCall)]
	fake.getAttrArgsForCall = append(fake.getAttrArgsForCall, struct {
		name    string
		context *fuse.Context
	}{name, context})
	fake.recordInvocation("GetAttr", []interface{}{name, context})
	fake.getAttrMutex.Unlock()
	if fake.GetAttrStub != nil {
		return fake.GetAttrStub(name, context)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAttrReturns.result1, fake.getAttrReturns.result2
}

func (fake *FakeFileSystem) GetAttrCallCount() int {
	fake.getAttrMutex.RLock()
	defer fake.getAttrMutex.RUnlock()
	return len(fake.getAttrArgsForCall)
}

func (fake *FakeFileSystem) GetAttrArgsForCall(i int) (string, *fuse.Context) {
	fake.getAttrMutex.RLock()
	defer fake.getAttrMutex.RUnlock()
	return fake.getAttrArgsForCall[i].name, fake.getAttrArgsForCall[i].context
}

func (fake *FakeFileSystem) GetAttrReturns(result1 *fuse.Attr, result2 fuse.Status) {
	fake.GetAttrStub = nil
	fake.getAttrReturns = struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) GetAttrReturnsOnCall(i int, result1 *fuse.Attr, result2 fuse.Status) {
	fake.GetAttrStub = nil
	if fake.getAttrReturnsOnCall == nil {
		fake.getAttrReturnsOnCall = make(map[int]struct {
			result1 *fuse.Attr
			result2 fuse.Status
		})
	}
	fake.getAttrReturnsOnCall[i] = struct {
		result1 *fuse.Attr
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) Chmod(name string, mode uint32, context *fuse.Context) (code fuse.Status) {
	fake.chmodMutex.Lock()
	ret, specificReturn := fake.chmodReturnsOnCall[len(fake.chmodArgsForCall)]
	fake.chmodArgsForCall = append(fake.chmodArgsForCall, struct {
		name    string
		mode    uint32
		context *fuse.Context
	}{name, mode, context})
	fake.recordInvocation("Chmod", []interface{}{name, mode, context})
	fake.chmodMutex.Unlock()
	if fake.ChmodStub != nil {
		return fake.ChmodStub(name, mode, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chmodReturns.result1
}

func (fake *FakeFileSystem) ChmodCallCount() int {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return len(fake.chmodArgsForCall)
}

func (fake *FakeFileSystem) ChmodArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return fake.chmodArgsForCall[i].name, fake.chmodArgsForCall[i].mode, fake.chmodArgsForCall[i].context
}

func (fake *FakeFileSystem) ChmodReturns(result1 fuse.Status) {
	fake.ChmodStub = nil
	fake.chmodReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) ChmodReturnsOnCall(i int, result1 fuse.Status) {
	fake.ChmodStub = nil
	if fake.chmodReturnsOnCall == nil {
		fake.chmodReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.chmodReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Chown(name string, uid uint32, gid uint32, context *fuse.Context) (code fuse.Status) {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		name    string
		uid     uint32
		gid     uint32
		context *fuse.Context
	}{name, uid, gid, context})
	fake.recordInvocation("Chown", []interface{}{name, uid, gid, context})
	fake.chownMutex.Unlock()
	if fake.ChownStub != nil {
		return fake.ChownStub(name, uid, gid, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chownReturns.result1
}

func (fake *FakeFileSystem) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeFileSystem) ChownArgsForCall(i int) (string, uint32, uint32, *fuse.Context) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return fake.chownArgsForCall[i].name, fake.chownArgsForCall[i].uid, fake.chownArgsForCall[i].gid, fake.chownArgsForCall[i].context
}

func (fake *FakeFileSystem) ChownReturns(result1 fuse.Status) {
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) ChownReturnsOnCall(i int, result1 fuse.Status) {
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Utimens(name string, Atime *time.Time, Mtime *time.Time, context *fuse.Context) (code fuse.Status) {
	fake.utimensMutex.Lock()
	ret, specificReturn := fake.utimensReturnsOnCall[len(fake.utimensArgsForCall)]
	fake.utimensArgsForCall = append(fake.utimensArgsForCall, struct {
		name    string
		Atime   *time.Time
		Mtime   *time.Time
		context *fuse.Context
	}{name, Atime, Mtime, context})
	fake.recordInvocation("Utimens", []interface{}{name, Atime, Mtime, context})
	fake.utimensMutex.Unlock()
	if fake.UtimensStub != nil {
		return fake.UtimensStub(name, Atime, Mtime, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.utimensReturns.result1
}

func (fake *FakeFileSystem) UtimensCallCount() int {
	fake.utimensMutex.RLock()
	defer fake.utimensMutex.RUnlock()
	return len(fake.utimensArgsForCall)
}

func (fake *FakeFileSystem) UtimensArgsForCall(i int) (string, *time.Time, *time.Time, *fuse.Context) {
	fake.utimensMutex.RLock()
	defer fake.utimensMutex.RUnlock()
	return fake.utimensArgsForCall[i].name, fake.utimensArgsForCall[i].Atime, fake.utimensArgsForCall[i].Mtime, fake.utimensArgsForCall[i].context
}

func (fake *FakeFileSystem) UtimensReturns(result1 fuse.Status) {
	fake.UtimensStub = nil
	fake.utimensReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) UtimensReturnsOnCall(i int, result1 fuse.Status) {
	fake.UtimensStub = nil
	if fake.utimensReturnsOnCall == nil {
		fake.utimensReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.utimensReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Truncate(name string, size uint64, context *fuse.Context) (code fuse.Status) {
	fake.truncateMutex.Lock()
	ret, specificReturn := fake.truncateReturnsOnCall[len(fake.truncateArgsForCall)]
	fake.truncateArgsForCall = append(fake.truncateArgsForCall, struct {
		name    string
		size    uint64
		context *fuse.Context
	}{name, size, context})
	fake.recordInvocation("Truncate", []interface{}{name, size, context})
	fake.truncateMutex.Unlock()
	if fake.TruncateStub != nil {
		return fake.TruncateStub(name, size, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.truncateReturns.result1
}

func (fake *FakeFileSystem) TruncateCallCount() int {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return len(fake.truncateArgsForCall)
}

func (fake *FakeFileSystem) TruncateArgsForCall(i int) (string, uint64, *fuse.Context) {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return fake.truncateArgsForCall[i].name, fake.truncateArgsForCall[i].size, fake.truncateArgsForCall[i].context
}

func (fake *FakeFileSystem) TruncateReturns(result1 fuse.Status) {
	fake.TruncateStub = nil
	fake.truncateReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) TruncateReturnsOnCall(i int, result1 fuse.Status) {
	fake.TruncateStub = nil
	if fake.truncateReturnsOnCall == nil {
		fake.truncateReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.truncateReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Access(name string, mode uint32, context *fuse.Context) (code fuse.Status) {
	fake.accessMutex.Lock()
	ret, specificReturn := fake.accessReturnsOnCall[len(fake.accessArgsForCall)]
	fake.accessArgsForCall = append(fake.accessArgsForCall, struct {
		name    string
		mode    uint32
		context *fuse.Context
	}{name, mode, context})
	fake.recordInvocation("Access", []interface{}{name, mode, context})
	fake.accessMutex.Unlock()
	if fake.AccessStub != nil {
		return fake.AccessStub(name, mode, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.accessReturns.result1
}

func (fake *FakeFileSystem) AccessCallCount() int {
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	return len(fake.accessArgsForCall)
}

func (fake *FakeFileSystem) AccessArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	return fake.accessArgsForCall[i].name, fake.accessArgsForCall[i].mode, fake.accessArgsForCall[i].context
}

func (fake *FakeFileSystem) AccessReturns(result1 fuse.Status) {
	fake.AccessStub = nil
	fake.accessReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) AccessReturnsOnCall(i int, result1 fuse.Status) {
	fake.AccessStub = nil
	if fake.accessReturnsOnCall == nil {
		fake.accessReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.accessReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Link(oldName string, newName string, context *fuse.Context) (code fuse.Status) {
	fake.linkMutex.Lock()
	ret, specificReturn := fake.linkReturnsOnCall[len(fake.linkArgsForCall)]
	fake.linkArgsForCall = append(fake.linkArgsForCall, struct {
		oldName string
		newName string
		context *fuse.Context
	}{oldName, newName, context})
	fake.recordInvocation("Link", []interface{}{oldName, newName, context})
	fake.linkMutex.Unlock()
	if fake.LinkStub != nil {
		return fake.LinkStub(oldName, newName, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.linkReturns.result1
}

func (fake *FakeFileSystem) LinkCallCount() int {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return len(fake.linkArgsForCall)
}

func (fake *FakeFileSystem) LinkArgsForCall(i int) (string, string, *fuse.Context) {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return fake.linkArgsForCall[i].oldName, fake.linkArgsForCall[i].newName, fake.linkArgsForCall[i].context
}

func (fake *FakeFileSystem) LinkReturns(result1 fuse.Status) {
	fake.LinkStub = nil
	fake.linkReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) LinkReturnsOnCall(i int, result1 fuse.Status) {
	fake.LinkStub = nil
	if fake.linkReturnsOnCall == nil {
		fake.linkReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.linkReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Mkdir(name string, mode uint32, context *fuse.Context) fuse.Status {
	fake.mkdirMutex.Lock()
	ret, specificReturn := fake.mkdirReturnsOnCall[len(fake.mkdirArgsForCall)]
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		name    string
		mode    uint32
		context *fuse.Context
	}{name, mode, context})
	fake.recordInvocation("Mkdir", []interface{}{name, mode, context})
	fake.mkdirMutex.Unlock()
	if fake.MkdirStub != nil {
		return fake.MkdirStub(name, mode, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mkdirReturns.result1
}

func (fake *FakeFileSystem) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeFileSystem) MkdirArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return fake.mkdirArgsForCall[i].name, fake.mkdirArgsForCall[i].mode, fake.mkdirArgsForCall[i].context
}

func (fake *FakeFileSystem) MkdirReturns(result1 fuse.Status) {
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) MkdirReturnsOnCall(i int, result1 fuse.Status) {
	fake.MkdirStub = nil
	if fake.mkdirReturnsOnCall == nil {
		fake.mkdirReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.mkdirReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Mknod(name string, mode uint32, dev uint32, context *fuse.Context) fuse.Status {
	fake.mknodMutex.Lock()
	ret, specificReturn := fake.mknodReturnsOnCall[len(fake.mknodArgsForCall)]
	fake.mknodArgsForCall = append(fake.mknodArgsForCall, struct {
		name    string
		mode    uint32
		dev     uint32
		context *fuse.Context
	}{name, mode, dev, context})
	fake.recordInvocation("Mknod", []interface{}{name, mode, dev, context})
	fake.mknodMutex.Unlock()
	if fake.MknodStub != nil {
		return fake.MknodStub(name, mode, dev, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mknodReturns.result1
}

func (fake *FakeFileSystem) MknodCallCount() int {
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	return len(fake.mknodArgsForCall)
}

func (fake *FakeFileSystem) MknodArgsForCall(i int) (string, uint32, uint32, *fuse.Context) {
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	return fake.mknodArgsForCall[i].name, fake.mknodArgsForCall[i].mode, fake.mknodArgsForCall[i].dev, fake.mknodArgsForCall[i].context
}

func (fake *FakeFileSystem) MknodReturns(result1 fuse.Status) {
	fake.MknodStub = nil
	fake.mknodReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) MknodReturnsOnCall(i int, result1 fuse.Status) {
	fake.MknodStub = nil
	if fake.mknodReturnsOnCall == nil {
		fake.mknodReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.mknodReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Rename(oldName string, newName string, context *fuse.Context) (code fuse.Status) {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		oldName string
		newName string
		context *fuse.Context
	}{oldName, newName, context})
	fake.recordInvocation("Rename", []interface{}{oldName, newName, context})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(oldName, newName, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameReturns.result1
}

func (fake *FakeFileSystem) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeFileSystem) RenameArgsForCall(i int) (string, string, *fuse.Context) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return fake.renameArgsForCall[i].oldName, fake.renameArgsForCall[i].newName, fake.renameArgsForCall[i].context
}

func (fake *FakeFileSystem) RenameReturns(result1 fuse.Status) {
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) RenameReturnsOnCall(i int, result1 fuse.Status) {
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Rmdir(name string, context *fuse.Context) (code fuse.Status) {
	fake.rmdirMutex.Lock()
	ret, specificReturn := fake.rmdirReturnsOnCall[len(fake.rmdirArgsForCall)]
	fake.rmdirArgsForCall = append(fake.rmdirArgsForCall, struct {
		name    string
		context *fuse.Context
	}{name, context})
	fake.recordInvocation("Rmdir", []interface{}{name, context})
	fake.rmdirMutex.Unlock()
	if fake.RmdirStub != nil {
		return fake.RmdirStub(name, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rmdirReturns.result1
}

func (fake *FakeFileSystem) RmdirCallCount() int {
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	return len(fake.rmdirArgsForCall)
}

func (fake *FakeFileSystem) RmdirArgsForCall(i int) (string, *fuse.Context) {
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	return fake.rmdirArgsForCall[i].name, fake.rmdirArgsForCall[i].context
}

func (fake *FakeFileSystem) RmdirReturns(result1 fuse.Status) {
	fake.RmdirStub = nil
	fake.rmdirReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) RmdirReturnsOnCall(i int, result1 fuse.Status) {
	fake.RmdirStub = nil
	if fake.rmdirReturnsOnCall == nil {
		fake.rmdirReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.rmdirReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Unlink(name string, context *fuse.Context) (code fuse.Status) {
	fake.unlinkMutex.Lock()
	ret, specificReturn := fake.unlinkReturnsOnCall[len(fake.unlinkArgsForCall)]
	fake.unlinkArgsForCall = append(fake.unlinkArgsForCall, struct {
		name    string
		context *fuse.Context
	}{name, context})
	fake.recordInvocation("Unlink", []interface{}{name, context})
	fake.unlinkMutex.Unlock()
	if fake.UnlinkStub != nil {
		return fake.UnlinkStub(name, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unlinkReturns.result1
}

func (fake *FakeFileSystem) UnlinkCallCount() int {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	return len(fake.unlinkArgsForCall)
}

func (fake *FakeFileSystem) UnlinkArgsForCall(i int) (string, *fuse.Context) {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	return fake.unlinkArgsForCall[i].name, fake.unlinkArgsForCall[i].context
}

func (fake *FakeFileSystem) UnlinkReturns(result1 fuse.Status) {
	fake.UnlinkStub = nil
	fake.unlinkReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) UnlinkReturnsOnCall(i int, result1 fuse.Status) {
	fake.UnlinkStub = nil
	if fake.unlinkReturnsOnCall == nil {
		fake.unlinkReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.unlinkReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) GetXAttr(name string, attribute string, context *fuse.Context) (data []byte, code fuse.Status) {
	fake.getXAttrMutex.Lock()
	ret, specificReturn := fake.getXAttrReturnsOnCall[len(fake.getXAttrArgsForCall)]
	fake.getXAttrArgsForCall = append(fake.getXAttrArgsForCall, struct {
		name      string
		attribute string
		context   *fuse.Context
	}{name, attribute, context})
	fake.recordInvocation("GetXAttr", []interface{}{name, attribute, context})
	fake.getXAttrMutex.Unlock()
	if fake.GetXAttrStub != nil {
		return fake.GetXAttrStub(name, attribute, context)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getXAttrReturns.result1, fake.getXAttrReturns.result2
}

func (fake *FakeFileSystem) GetXAttrCallCount() int {
	fake.getXAttrMutex.RLock()
	defer fake.getXAttrMutex.RUnlock()
	return len(fake.getXAttrArgsForCall)
}

func (fake *FakeFileSystem) GetXAttrArgsForCall(i int) (string, string, *fuse.Context) {
	fake.getXAttrMutex.RLock()
	defer fake.getXAttrMutex.RUnlock()
	return fake.getXAttrArgsForCall[i].name, fake.getXAttrArgsForCall[i].attribute, fake.getXAttrArgsForCall[i].context
}

func (fake *FakeFileSystem) GetXAttrReturns(result1 []byte, result2 fuse.Status) {
	fake.GetXAttrStub = nil
	fake.getXAttrReturns = struct {
		result1 []byte
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) GetXAttrReturnsOnCall(i int, result1 []byte, result2 fuse.Status) {
	fake.GetXAttrStub = nil
	if fake.getXAttrReturnsOnCall == nil {
		fake.getXAttrReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 fuse.Status
		})
	}
	fake.getXAttrReturnsOnCall[i] = struct {
		result1 []byte
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) ListXAttr(name string, context *fuse.Context) (attributes []string, code fuse.Status) {
	fake.listXAttrMutex.Lock()
	ret, specificReturn := fake.listXAttrReturnsOnCall[len(fake.listXAttrArgsForCall)]
	fake.listXAttrArgsForCall = append(fake.listXAttrArgsForCall, struct {
		name    string
		context *fuse.Context
	}{name, context})
	fake.recordInvocation("ListXAttr", []interface{}{name, context})
	fake.listXAttrMutex.Unlock()
	if fake.ListXAttrStub != nil {
		return fake.ListXAttrStub(name, context)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listXAttrReturns.result1, fake.listXAttrReturns.result2
}

func (fake *FakeFileSystem) ListXAttrCallCount() int {
	fake.listXAttrMutex.RLock()
	defer fake.listXAttrMutex.RUnlock()
	return len(fake.listXAttrArgsForCall)
}

func (fake *FakeFileSystem) ListXAttrArgsForCall(i int) (string, *fuse.Context) {
	fake.listXAttrMutex.RLock()
	defer fake.listXAttrMutex.RUnlock()
	return fake.listXAttrArgsForCall[i].name, fake.listXAttrArgsForCall[i].context
}

func (fake *FakeFileSystem) ListXAttrReturns(result1 []string, result2 fuse.Status) {
	fake.ListXAttrStub = nil
	fake.listXAttrReturns = struct {
		result1 []string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) ListXAttrReturnsOnCall(i int, result1 []string, result2 fuse.Status) {
	fake.ListXAttrStub = nil
	if fake.listXAttrReturnsOnCall == nil {
		fake.listXAttrReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 fuse.Status
		})
	}
	fake.listXAttrReturnsOnCall[i] = struct {
		result1 []string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) RemoveXAttr(name string, attr string, context *fuse.Context) fuse.Status {
	fake.removeXAttrMutex.Lock()
	ret, specificReturn := fake.removeXAttrReturnsOnCall[len(fake.removeXAttrArgsForCall)]
	fake.removeXAttrArgsForCall = append(fake.removeXAttrArgsForCall, struct {
		name    string
		attr    string
		context *fuse.Context
	}{name, attr, context})
	fake.recordInvocation("RemoveXAttr", []interface{}{name, attr, context})
	fake.removeXAttrMutex.Unlock()
	if fake.RemoveXAttrStub != nil {
		return fake.RemoveXAttrStub(name, attr, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeXAttrReturns.result1
}

func (fake *FakeFileSystem) RemoveXAttrCallCount() int {
	fake.removeXAttrMutex.RLock()
	defer fake.removeXAttrMutex.RUnlock()
	return len(fake.removeXAttrArgsForCall)
}

func (fake *FakeFileSystem) RemoveXAttrArgsForCall(i int) (string, string, *fuse.Context) {
	fake.removeXAttrMutex.RLock()
	defer fake.removeXAttrMutex.RUnlock()
	return fake.removeXAttrArgsForCall[i].name, fake.removeXAttrArgsForCall[i].attr, fake.removeXAttrArgsForCall[i].context
}

func (fake *FakeFileSystem) RemoveXAttrReturns(result1 fuse.Status) {
	fake.RemoveXAttrStub = nil
	fake.removeXAttrReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) RemoveXAttrReturnsOnCall(i int, result1 fuse.Status) {
	fake.RemoveXAttrStub = nil
	if fake.removeXAttrReturnsOnCall == nil {
		fake.removeXAttrReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.removeXAttrReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) SetXAttr(name string, attr string, data []byte, flags int, context *fuse.Context) fuse.Status {
	var dataCopy []byte
	if data != nil {
		dataCopy = make([]byte, len(data))
		copy(dataCopy, data)
	}
	fake.setXAttrMutex.Lock()
	ret, specificReturn := fake.setXAttrReturnsOnCall[len(fake.setXAttrArgsForCall)]
	fake.setXAttrArgsForCall = append(fake.setXAttrArgsForCall, struct {
		name    string
		attr    string
		data    []byte
		flags   int
		context *fuse.Context
	}{name, attr, dataCopy, flags, context})
	fake.recordInvocation("SetXAttr", []interface{}{name, attr, dataCopy, flags, context})
	fake.setXAttrMutex.Unlock()
	if fake.SetXAttrStub != nil {
		return fake.SetXAttrStub(name, attr, data, flags, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setXAttrReturns.result1
}

func (fake *FakeFileSystem) SetXAttrCallCount() int {
	fake.setXAttrMutex.RLock()
	defer fake.setXAttrMutex.RUnlock()
	return len(fake.setXAttrArgsForCall)
}

func (fake *FakeFileSystem) SetXAttrArgsForCall(i int) (string, string, []byte, int, *fuse.Context) {
	fake.setXAttrMutex.RLock()
	defer fake.setXAttrMutex.RUnlock()
	return fake.setXAttrArgsForCall[i].name, fake.setXAttrArgsForCall[i].attr, fake.setXAttrArgsForCall[i].data, fake.setXAttrArgsForCall[i].flags, fake.setXAttrArgsForCall[i].context
}

func (fake *FakeFileSystem) SetXAttrReturns(result1 fuse.Status) {
	fake.SetXAttrStub = nil
	fake.setXAttrReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) SetXAttrReturnsOnCall(i int, result1 fuse.Status) {
	fake.SetXAttrStub = nil
	if fake.setXAttrReturnsOnCall == nil {
		fake.setXAttrReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.setXAttrReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) OnMount(nodeFs *pathfs.PathNodeFs) {
	fake.onMountMutex.Lock()
	fake.onMountArgsForCall = append(fake.onMountArgsForCall, struct {
		nodeFs *pathfs.PathNodeFs
	}{nodeFs})
	fake.recordInvocation("OnMount", []interface{}{nodeFs})
	fake.onMountMutex.Unlock()
	if fake.OnMountStub != nil {
		fake.OnMountStub(nodeFs)
	}
}

func (fake *FakeFileSystem) OnMountCallCount() int {
	fake.onMountMutex.RLock()
	defer fake.onMountMutex.RUnlock()
	return len(fake.onMountArgsForCall)
}

func (fake *FakeFileSystem) OnMountArgsForCall(i int) *pathfs.PathNodeFs {
	fake.onMountMutex.RLock()
	defer fake.onMountMutex.RUnlock()
	return fake.onMountArgsForCall[i].nodeFs
}

func (fake *FakeFileSystem) OnUnmount() {
	fake.onUnmountMutex.Lock()
	fake.onUnmountArgsForCall = append(fake.onUnmountArgsForCall, struct{}{})
	fake.recordInvocation("OnUnmount", []interface{}{})
	fake.onUnmountMutex.Unlock()
	if fake.OnUnmountStub != nil {
		fake.OnUnmountStub()
	}
}

func (fake *FakeFileSystem) OnUnmountCallCount() int {
	fake.onUnmountMutex.RLock()
	defer fake.onUnmountMutex.RUnlock()
	return len(fake.onUnmountArgsForCall)
}

func (fake *FakeFileSystem) Open(name string, flags uint32, context *fuse.Context) (file nodefs.File, code fuse.Status) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		name    string
		flags   uint32
		context *fuse.Context
	}{name, flags, context})
	fake.recordInvocation("Open", []interface{}{name, flags, context})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(name, flags, context)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openReturns.result1, fake.openReturns.result2
}

func (fake *FakeFileSystem) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeFileSystem) OpenArgsForCall(i int) (string, uint32, *fuse.Context) {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return fake.openArgsForCall[i].name, fake.openArgsForCall[i].flags, fake.openArgsForCall[i].context
}

func (fake *FakeFileSystem) OpenReturns(result1 nodefs.File, result2 fuse.Status) {
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) OpenReturnsOnCall(i int, result1 nodefs.File, result2 fuse.Status) {
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 nodefs.File
			result2 fuse.Status
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) Create(name string, flags uint32, mode uint32, context *fuse.Context) (file nodefs.File, code fuse.Status) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		name    string
		flags   uint32
		mode    uint32
		context *fuse.Context
	}{name, flags, mode, context})
	fake.recordInvocation("Create", []interface{}{name, flags, mode, context})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(name, flags, mode, context)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeFileSystem) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeFileSystem) CreateArgsForCall(i int) (string, uint32, uint32, *fuse.Context) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].name, fake.createArgsForCall[i].flags, fake.createArgsForCall[i].mode, fake.createArgsForCall[i].context
}

func (fake *FakeFileSystem) CreateReturns(result1 nodefs.File, result2 fuse.Status) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) CreateReturnsOnCall(i int, result1 nodefs.File, result2 fuse.Status) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 nodefs.File
			result2 fuse.Status
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 nodefs.File
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) OpenDir(name string, context *fuse.Context) (stream []fuse.DirEntry, code fuse.Status) {
	fake.openDirMutex.Lock()
	ret, specificReturn := fake.openDirReturnsOnCall[len(fake.openDirArgsForCall)]
	fake.openDirArgsForCall = append(fake.openDirArgsForCall, struct {
		name    string
		context *fuse.Context
	}{name, context})
	fake.recordInvocation("OpenDir", []interface{}{name, context})
	fake.openDirMutex.Unlock()
	if fake.OpenDirStub != nil {
		return fake.OpenDirStub(name, context)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openDirReturns.result1, fake.openDirReturns.result2
}

func (fake *FakeFileSystem) OpenDirCallCount() int {
	fake.openDirMutex.RLock()
	defer fake.openDirMutex.RUnlock()
	return len(fake.openDirArgsForCall)
}

func (fake *FakeFileSystem) OpenDirArgsForCall(i int) (string, *fuse.Context) {
	fake.openDirMutex.RLock()
	defer fake.openDirMutex.RUnlock()
	return fake.openDirArgsForCall[i].name, fake.openDirArgsForCall[i].context
}

func (fake *FakeFileSystem) OpenDirReturns(result1 []fuse.DirEntry, result2 fuse.Status) {
	fake.OpenDirStub = nil
	fake.openDirReturns = struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) OpenDirReturnsOnCall(i int, result1 []fuse.DirEntry, result2 fuse.Status) {
	fake.OpenDirStub = nil
	if fake.openDirReturnsOnCall == nil {
		fake.openDirReturnsOnCall = make(map[int]struct {
			result1 []fuse.DirEntry
			result2 fuse.Status
		})
	}
	fake.openDirReturnsOnCall[i] = struct {
		result1 []fuse.DirEntry
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) Symlink(value string, linkName string, context *fuse.Context) (code fuse.Status) {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		value    string
		linkName string
		context  *fuse.Context
	}{value, linkName, context})
	fake.recordInvocation("Symlink", []interface{}{value, linkName, context})
	fake.symlinkMutex.Unlock()
	if fake.SymlinkStub != nil {
		return fake.SymlinkStub(value, linkName, context)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.symlinkReturns.result1
}

func (fake *FakeFileSystem) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeFileSystem) SymlinkArgsForCall(i int) (string, string, *fuse.Context) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return fake.symlinkArgsForCall[i].value, fake.symlinkArgsForCall[i].linkName, fake.symlinkArgsForCall[i].context
}

func (fake *FakeFileSystem) SymlinkReturns(result1 fuse.Status) {
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) SymlinkReturnsOnCall(i int, result1 fuse.Status) {
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 fuse.Status
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 fuse.Status
	}{result1}
}

func (fake *FakeFileSystem) Readlink(name string, context *fuse.Context) (string, fuse.Status) {
	fake.readlinkMutex.Lock()
	ret, specificReturn := fake.readlinkReturnsOnCall[len(fake.readlinkArgsForCall)]
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		name    string
		context *fuse.Context
	}{name, context})
	fake.recordInvocation("Readlink", []interface{}{name, context})
	fake.readlinkMutex.Unlock()
	if fake.ReadlinkStub != nil {
		return fake.ReadlinkStub(name, context)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readlinkReturns.result1, fake.readlinkReturns.result2
}

func (fake *FakeFileSystem) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeFileSystem) ReadlinkArgsForCall(i int) (string, *fuse.Context) {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return fake.readlinkArgsForCall[i].name, fake.readlinkArgsForCall[i].context
}

func (fake *FakeFileSystem) ReadlinkReturns(result1 string, result2 fuse.Status) {
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadlinkReturnsOnCall(i int, result1 string, result2 fuse.Status) {
	fake.ReadlinkStub = nil
	if fake.readlinkReturnsOnCall == nil {
		fake.readlinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 fuse.Status
		})
	}
	fake.readlinkReturnsOnCall[i] = struct {
		result1 string
		result2 fuse.Status
	}{result1, result2}
}

func (fake *FakeFileSystem) StatFs(name string) *fuse.StatfsOut {
	fake.statFsMutex.Lock()
	ret, specificReturn := fake.statFsReturnsOnCall[len(fake.statFsArgsForCall)]
	fake.statFsArgsForCall = append(fake.statFsArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("StatFs", []interface{}{name})
	fake.statFsMutex.Unlock()
	if fake.StatFsStub != nil {
		return fake.StatFsStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.statFsReturns.result1
}

func (fake *FakeFileSystem) StatFsCallCount() int {
	fake.statFsMutex.RLock()
	defer fake.statFsMutex.RUnlock()
	return len(fake.statFsArgsForCall)
}

func (fake *FakeFileSystem) StatFsArgsForCall(i int) string {
	fake.statFsMutex.RLock()
	defer fake.statFsMutex.RUnlock()
	return fake.statFsArgsForCall[i].name
}

func (fake *FakeFileSystem) StatFsReturns(result1 *fuse.StatfsOut) {
	fake.StatFsStub = nil
	fake.statFsReturns = struct {
		result1 *fuse.StatfsOut
	}{result1}
}

func (fake *FakeFileSystem) StatFsReturnsOnCall(i int, result1 *fuse.StatfsOut) {
	fake.StatFsStub = nil
	if fake.statFsReturnsOnCall == nil {
		fake.statFsReturnsOnCall = make(map[int]struct {
			result1 *fuse.StatfsOut
		})
	}
	fake.statFsReturnsOnCall[i] = struct {
		result1 *fuse.StatfsOut
	}{result1}
}

func (fake *FakeFileSystem) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.setDebugMutex.RLock()
	defer fake.setDebugMutex.RUnlock()
	fake.getAttrMutex.RLock()
	defer fake.getAttrMutex.RUnlock()
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.utimensMutex.RLock()
	defer fake.utimensMutex.RUnlock()
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	fake.getXAttrMutex.RLock()
	defer fake.getXAttrMutex.RUnlock()
	fake.listXAttrMutex.RLock()
	defer fake.listXAttrMutex.RUnlock()
	fake.removeXAttrMutex.RLock()
	defer fake.removeXAttrMutex.RUnlock()
	fake.setXAttrMutex.RLock()
	defer fake.setXAttrMutex.RUnlock()
	fake.onMountMutex.RLock()
	defer fake.onMountMutex.RUnlock()
	fake.onUnmountMutex.RLock()
	defer fake.onUnmountMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.openDirMutex.RLock()
	defer fake.openDirMutex.RUnlock()
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	fake.statFsMutex.RLock()
	defer fake.statFsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFileSystem) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pathfs.FileSystem = new(FakeFileSystem)
